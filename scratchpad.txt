CHEAT-SHEET:
============
- grep -E "class|def" app/tests.py - Command to check the list of unit tests

GUIDELINES:
===========

## Test Driven Development
- Flow is to create a "broken state" (a test with an expected fail), do the minimum code to go to a "working state" (all tests pass) and then refactor the code as needed (refactor tests or app code but not both at the same time)
    - DonÂ´t forget the 'Refactor' in Red, Green, Refactor
    - The whole point of having tests is to allow refactoring of the code

## Test folder structure:
- One file (and one class) per user story
- Group Unit Tests for an app inside a tests folder **with a __init__.py file**
- One file for each of test_views / test_models / test_templates

## What to test for **views**

1. Check the template used
2. Check each element in the template context
3. Check any objects are the correct ones, or querysets have the correct objects
4. Check any forms are the correct class
5. Checl any template logic (e.g. when inserting in a list it inserts in the right list and not in another list)
6. For views that handle POST requests check both the valid and invalid case
7. Sanity check that form is rendered and its errors displayed

## Django
- Good practice to include as much validation as possible in the models (everything ends in single database so best place to check). Use your_model_object.***full_clean()*** in views to run all validations and it will raise an exception if any fails

TODOs:
======

* How to send emails
* Generating and recognising unique tokens
* How to authenticate someone in Django
* What steps will the user have to go through?
